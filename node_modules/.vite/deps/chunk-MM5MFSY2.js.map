{
  "version": 3,
  "sources": ["../../@tsparticles/move-base/browser/Utils.js", "../../@tsparticles/move-base/browser/BaseMover.js", "../../@tsparticles/move-base/browser/index.js", "../../@tsparticles/shape-circle/browser/Utils.js", "../../@tsparticles/shape-circle/browser/CircleDrawer.js", "../../@tsparticles/shape-circle/browser/index.js", "../../@tsparticles/updater-color/browser/ColorUpdater.js", "../../@tsparticles/updater-color/browser/index.js", "../../@tsparticles/plugin-hex-color/browser/HexColorManager.js", "../../@tsparticles/plugin-hex-color/browser/index.js", "../../@tsparticles/plugin-hsl-color/browser/HslColorManager.js", "../../@tsparticles/plugin-hsl-color/browser/index.js", "../../@tsparticles/updater-opacity/browser/OpacityUpdater.js", "../../@tsparticles/updater-opacity/browser/index.js", "../../@tsparticles/updater-out-modes/browser/Utils.js", "../../@tsparticles/updater-out-modes/browser/BounceOutMode.js", "../../@tsparticles/updater-out-modes/browser/DestroyOutMode.js", "../../@tsparticles/updater-out-modes/browser/NoneOutMode.js", "../../@tsparticles/updater-out-modes/browser/OutOutMode.js", "../../@tsparticles/updater-out-modes/browser/OutOfCanvasUpdater.js", "../../@tsparticles/updater-out-modes/browser/index.js", "../../@tsparticles/plugin-rgb-color/browser/RgbColorManager.js", "../../@tsparticles/plugin-rgb-color/browser/index.js", "../../@tsparticles/updater-size/browser/SizeUpdater.js", "../../@tsparticles/updater-size/browser/index.js", "../../@tsparticles/basic/browser/index.js", "../../@tsparticles/interaction-particles-links/browser/CircleWarp.js", "../../@tsparticles/interaction-particles-links/browser/Options/Classes/LinksShadow.js", "../../@tsparticles/interaction-particles-links/browser/Options/Classes/LinksTriangle.js", "../../@tsparticles/interaction-particles-links/browser/Options/Classes/Links.js", "../../@tsparticles/interaction-particles-links/browser/Linker.js", "../../@tsparticles/interaction-particles-links/browser/interaction.js", "../../@tsparticles/interaction-particles-links/browser/Utils.js", "../../@tsparticles/interaction-particles-links/browser/LinkInstance.js", "../../@tsparticles/interaction-particles-links/browser/LinksPlugin.js", "../../@tsparticles/interaction-particles-links/browser/plugin.js", "../../@tsparticles/interaction-particles-links/browser/index.js"],
  "sourcesContent": ["import { RotateDirection, clamp, getDistance, getDistances, getRandom, getRangeValue, } from \"@tsparticles/engine\";\r\nconst half = 0.5, double = 2, minVelocity = 0, identity = 1, moveSpeedFactor = 60, minSpinRadius = 0, spinFactor = 0.01, doublePI = Math.PI * double;\r\nexport function applyDistance(particle) {\r\n    const initialPosition = particle.initialPosition, { dx, dy } = getDistances(initialPosition, particle.position), dxFixed = Math.abs(dx), dyFixed = Math.abs(dy), { maxDistance } = particle.retina, hDistance = maxDistance.horizontal, vDistance = maxDistance.vertical;\r\n    if (!hDistance && !vDistance) {\r\n        return;\r\n    }\r\n    const hasHDistance = (hDistance && dxFixed >= hDistance) ?? false, hasVDistance = (vDistance && dyFixed >= vDistance) ?? false;\r\n    if ((hasHDistance || hasVDistance) && !particle.misplaced) {\r\n        particle.misplaced = (!!hDistance && dxFixed > hDistance) || (!!vDistance && dyFixed > vDistance);\r\n        if (hDistance) {\r\n            particle.velocity.x = particle.velocity.y * half - particle.velocity.x;\r\n        }\r\n        if (vDistance) {\r\n            particle.velocity.y = particle.velocity.x * half - particle.velocity.y;\r\n        }\r\n    }\r\n    else if ((!hDistance || dxFixed < hDistance) && (!vDistance || dyFixed < vDistance) && particle.misplaced) {\r\n        particle.misplaced = false;\r\n    }\r\n    else if (particle.misplaced) {\r\n        const pos = particle.position, vel = particle.velocity;\r\n        if (hDistance &&\r\n            ((pos.x < initialPosition.x && vel.x < minVelocity) || (pos.x > initialPosition.x && vel.x > minVelocity))) {\r\n            vel.x *= -getRandom();\r\n        }\r\n        if (vDistance &&\r\n            ((pos.y < initialPosition.y && vel.y < minVelocity) || (pos.y > initialPosition.y && vel.y > minVelocity))) {\r\n            vel.y *= -getRandom();\r\n        }\r\n    }\r\n}\r\nexport function move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, delta) {\r\n    applyPath(particle, delta);\r\n    const gravityOptions = particle.gravity, gravityFactor = gravityOptions?.enable && gravityOptions.inverse ? -identity : identity;\r\n    if (moveDrift && moveSpeed) {\r\n        particle.velocity.x += (moveDrift * delta.factor) / (moveSpeedFactor * moveSpeed);\r\n    }\r\n    if (gravityOptions?.enable && moveSpeed) {\r\n        particle.velocity.y +=\r\n            (gravityFactor * (gravityOptions.acceleration * delta.factor)) / (moveSpeedFactor * moveSpeed);\r\n    }\r\n    const decay = particle.moveDecay;\r\n    particle.velocity.multTo(decay);\r\n    const velocity = particle.velocity.mult(moveSpeed);\r\n    if (gravityOptions?.enable &&\r\n        maxSpeed > minVelocity &&\r\n        ((!gravityOptions.inverse && velocity.y >= minVelocity && velocity.y >= maxSpeed) ||\r\n            (gravityOptions.inverse && velocity.y <= minVelocity && velocity.y <= -maxSpeed))) {\r\n        velocity.y = gravityFactor * maxSpeed;\r\n        if (moveSpeed) {\r\n            particle.velocity.y = velocity.y / moveSpeed;\r\n        }\r\n    }\r\n    const zIndexOptions = particle.options.zIndex, zVelocityFactor = (identity - particle.zIndexFactor) ** zIndexOptions.velocityRate;\r\n    velocity.multTo(zVelocityFactor);\r\n    const { position } = particle;\r\n    position.addTo(velocity);\r\n    if (moveOptions.vibrate) {\r\n        position.x += Math.sin(position.x * Math.cos(position.y));\r\n        position.y += Math.cos(position.y * Math.sin(position.x));\r\n    }\r\n}\r\nexport function spin(particle, moveSpeed) {\r\n    const container = particle.container;\r\n    if (!particle.spin) {\r\n        return;\r\n    }\r\n    const spinClockwise = particle.spin.direction === RotateDirection.clockwise, updateFunc = {\r\n        x: spinClockwise ? Math.cos : Math.sin,\r\n        y: spinClockwise ? Math.sin : Math.cos,\r\n    };\r\n    particle.position.x = particle.spin.center.x + particle.spin.radius * updateFunc.x(particle.spin.angle);\r\n    particle.position.y = particle.spin.center.y + particle.spin.radius * updateFunc.y(particle.spin.angle);\r\n    particle.spin.radius += particle.spin.acceleration;\r\n    const maxCanvasSize = Math.max(container.canvas.size.width, container.canvas.size.height), halfMaxSize = maxCanvasSize * half;\r\n    if (particle.spin.radius > halfMaxSize) {\r\n        particle.spin.radius = halfMaxSize;\r\n        particle.spin.acceleration *= -identity;\r\n    }\r\n    else if (particle.spin.radius < minSpinRadius) {\r\n        particle.spin.radius = minSpinRadius;\r\n        particle.spin.acceleration *= -identity;\r\n    }\r\n    particle.spin.angle += moveSpeed * spinFactor * (identity - particle.spin.radius / maxCanvasSize);\r\n}\r\nexport function applyPath(particle, delta) {\r\n    const particlesOptions = particle.options, pathOptions = particlesOptions.move.path, pathEnabled = pathOptions.enable;\r\n    if (!pathEnabled) {\r\n        return;\r\n    }\r\n    if (particle.lastPathTime <= particle.pathDelay) {\r\n        particle.lastPathTime += delta.value;\r\n        return;\r\n    }\r\n    const path = particle.pathGenerator?.generate(particle, delta);\r\n    if (path) {\r\n        particle.velocity.addTo(path);\r\n    }\r\n    if (pathOptions.clamp) {\r\n        particle.velocity.x = clamp(particle.velocity.x, -identity, identity);\r\n        particle.velocity.y = clamp(particle.velocity.y, -identity, identity);\r\n    }\r\n    particle.lastPathTime -= particle.pathDelay;\r\n}\r\nexport function getProximitySpeedFactor(particle) {\r\n    return particle.slow.inRange ? particle.slow.factor : identity;\r\n}\r\nexport function initSpin(particle) {\r\n    const container = particle.container, options = particle.options, spinOptions = options.move.spin;\r\n    if (!spinOptions.enable) {\r\n        return;\r\n    }\r\n    const spinPos = spinOptions.position ?? { x: 50, y: 50 }, spinFactor = 0.01, spinCenter = {\r\n        x: spinPos.x * spinFactor * container.canvas.size.width,\r\n        y: spinPos.y * spinFactor * container.canvas.size.height,\r\n    }, pos = particle.getPosition(), distance = getDistance(pos, spinCenter), spinAcceleration = getRangeValue(spinOptions.acceleration);\r\n    particle.retina.spinAcceleration = spinAcceleration * container.retina.pixelRatio;\r\n    particle.spin = {\r\n        center: spinCenter,\r\n        direction: particle.velocity.x >= minVelocity ? RotateDirection.clockwise : RotateDirection.counterClockwise,\r\n        angle: getRandom() * doublePI,\r\n        radius: distance,\r\n        acceleration: particle.retina.spinAcceleration,\r\n    };\r\n}\r\n", "import { getRangeMax, getRangeValue } from \"@tsparticles/engine\";\r\nimport { applyDistance, getProximitySpeedFactor, initSpin, move, spin } from \"./Utils.js\";\r\nconst diffFactor = 2, defaultSizeFactor = 1, defaultDeltaFactor = 1;\r\nexport class BaseMover {\r\n    init(particle) {\r\n        const options = particle.options, gravityOptions = options.move.gravity;\r\n        particle.gravity = {\r\n            enable: gravityOptions.enable,\r\n            acceleration: getRangeValue(gravityOptions.acceleration),\r\n            inverse: gravityOptions.inverse,\r\n        };\r\n        initSpin(particle);\r\n    }\r\n    isEnabled(particle) {\r\n        return !particle.destroyed && particle.options.move.enable;\r\n    }\r\n    move(particle, delta) {\r\n        const particleOptions = particle.options, moveOptions = particleOptions.move;\r\n        if (!moveOptions.enable) {\r\n            return;\r\n        }\r\n        const container = particle.container, pxRatio = container.retina.pixelRatio;\r\n        particle.retina.moveSpeed ??= getRangeValue(moveOptions.speed) * pxRatio;\r\n        particle.retina.moveDrift ??= getRangeValue(particle.options.move.drift) * pxRatio;\r\n        const slowFactor = getProximitySpeedFactor(particle), baseSpeed = particle.retina.moveSpeed * container.retina.reduceFactor, moveDrift = particle.retina.moveDrift, maxSize = getRangeMax(particleOptions.size.value) * pxRatio, sizeFactor = moveOptions.size ? particle.getRadius() / maxSize : defaultSizeFactor, deltaFactor = delta.factor || defaultDeltaFactor, moveSpeed = (baseSpeed * sizeFactor * slowFactor * deltaFactor) / diffFactor, maxSpeed = particle.retina.maxSpeed ?? container.retina.maxSpeed;\r\n        if (moveOptions.spin.enable) {\r\n            spin(particle, moveSpeed);\r\n        }\r\n        else {\r\n            move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, delta);\r\n        }\r\n        applyDistance(particle);\r\n    }\r\n}\r\n", "import { BaseMover } from \"./BaseMover.js\";\r\nexport async function loadBaseMover(engine, refresh = true) {\r\n    engine.checkVersion(\"3.8.1\");\r\n    await engine.addMover(\"base\", () => {\r\n        return Promise.resolve(new BaseMover());\r\n    }, refresh);\r\n}\r\n", "const double = 2, doublePI = Math.PI * double, minAngle = 0, origin = { x: 0, y: 0 };\r\nexport function drawCircle(data) {\r\n    const { context, particle, radius } = data;\r\n    if (!particle.circleRange) {\r\n        particle.circleRange = { min: minAngle, max: doublePI };\r\n    }\r\n    const circleRange = particle.circleRange;\r\n    context.arc(origin.x, origin.y, radius, circleRange.min, circleRange.max, false);\r\n}\r\n", "import { degToRad, isObject } from \"@tsparticles/engine\";\r\nimport { drawCircle } from \"./Utils.js\";\r\nconst sides = 12, maxAngle = 360, minAngle = 0;\r\nexport class CircleDrawer {\r\n    constructor() {\r\n        this.validTypes = [\"circle\"];\r\n    }\r\n    draw(data) {\r\n        drawCircle(data);\r\n    }\r\n    getSidesCount() {\r\n        return sides;\r\n    }\r\n    particleInit(container, particle) {\r\n        const shapeData = particle.shapeData, angle = shapeData?.angle ?? {\r\n            max: maxAngle,\r\n            min: minAngle,\r\n        };\r\n        particle.circleRange = !isObject(angle)\r\n            ? {\r\n                min: minAngle,\r\n                max: degToRad(angle),\r\n            }\r\n            : { min: degToRad(angle.min), max: degToRad(angle.max) };\r\n    }\r\n}\r\n", "import { CircleDrawer } from \"./CircleDrawer.js\";\r\nexport async function loadCircleShape(engine, refresh = true) {\r\n    engine.checkVersion(\"3.8.1\");\r\n    await engine.addShape(new CircleDrawer(), refresh);\r\n}\r\n", "import { getHslAnimationFromHsl, rangeColorToHsl, updateColor, } from \"@tsparticles/engine\";\r\nexport class ColorUpdater {\r\n    constructor(container, engine) {\r\n        this._container = container;\r\n        this._engine = engine;\r\n    }\r\n    init(particle) {\r\n        const hslColor = rangeColorToHsl(this._engine, particle.options.color, particle.id, particle.options.reduceDuplicates);\r\n        if (hslColor) {\r\n            particle.color = getHslAnimationFromHsl(hslColor, particle.options.color.animation, this._container.retina.reduceFactor);\r\n        }\r\n    }\r\n    isEnabled(particle) {\r\n        const { h: hAnimation, s: sAnimation, l: lAnimation } = particle.options.color.animation, { color } = particle;\r\n        return (!particle.destroyed &&\r\n            !particle.spawning &&\r\n            ((color?.h.value !== undefined && hAnimation.enable) ||\r\n                (color?.s.value !== undefined && sAnimation.enable) ||\r\n                (color?.l.value !== undefined && lAnimation.enable)));\r\n    }\r\n    update(particle, delta) {\r\n        updateColor(particle.color, delta);\r\n    }\r\n}\r\n", "import { ColorUpdater } from \"./ColorUpdater.js\";\r\nexport async function loadColorUpdater(engine, refresh = true) {\r\n    engine.checkVersion(\"3.8.1\");\r\n    await engine.addParticleUpdater(\"color\", container => {\r\n        return Promise.resolve(new ColorUpdater(container, engine));\r\n    }, refresh);\r\n}\r\n", "var RgbIndexes;\r\n(function (RgbIndexes) {\r\n    RgbIndexes[RgbIndexes[\"r\"] = 1] = \"r\";\r\n    RgbIndexes[RgbIndexes[\"g\"] = 2] = \"g\";\r\n    RgbIndexes[RgbIndexes[\"b\"] = 3] = \"b\";\r\n    RgbIndexes[RgbIndexes[\"a\"] = 4] = \"a\";\r\n})(RgbIndexes || (RgbIndexes = {}));\r\nconst shorthandHexRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])([a-f\\d])?$/i, hexRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})?$/i, hexRadix = 16, defaultAlpha = 1, alphaFactor = 0xff;\r\nexport class HexColorManager {\r\n    constructor() {\r\n        this.key = \"hex\";\r\n        this.stringPrefix = \"#\";\r\n    }\r\n    handleColor(color) {\r\n        return this._parseString(color.value);\r\n    }\r\n    handleRangeColor(color) {\r\n        return this._parseString(color.value);\r\n    }\r\n    parseString(input) {\r\n        return this._parseString(input);\r\n    }\r\n    _parseString(hexColor) {\r\n        if (typeof hexColor !== \"string\") {\r\n            return;\r\n        }\r\n        if (!hexColor?.startsWith(this.stringPrefix)) {\r\n            return;\r\n        }\r\n        const hexFixed = hexColor.replace(shorthandHexRegex, (_, r, g, b, a) => {\r\n            return r + r + g + g + b + b + (a !== undefined ? a + a : \"\");\r\n        }), result = hexRegex.exec(hexFixed);\r\n        return result\r\n            ? {\r\n                a: result[RgbIndexes.a] !== undefined\r\n                    ? parseInt(result[RgbIndexes.a], hexRadix) / alphaFactor\r\n                    : defaultAlpha,\r\n                b: parseInt(result[RgbIndexes.b], hexRadix),\r\n                g: parseInt(result[RgbIndexes.g], hexRadix),\r\n                r: parseInt(result[RgbIndexes.r], hexRadix),\r\n            }\r\n            : undefined;\r\n    }\r\n}\r\n", "import { HexColorManager } from \"./HexColorManager.js\";\r\nexport async function loadHexColorPlugin(engine, refresh = true) {\r\n    engine.checkVersion(\"3.8.1\");\r\n    await engine.addColorManager(new HexColorManager(), refresh);\r\n}\r\n", "import { getRangeValue, hslToRgb, hslaToRgba, parseAlpha, } from \"@tsparticles/engine\";\r\nvar HslIndexes;\r\n(function (HslIndexes) {\r\n    HslIndexes[HslIndexes[\"h\"] = 1] = \"h\";\r\n    HslIndexes[HslIndexes[\"s\"] = 2] = \"s\";\r\n    HslIndexes[HslIndexes[\"l\"] = 3] = \"l\";\r\n    HslIndexes[HslIndexes[\"a\"] = 5] = \"a\";\r\n})(HslIndexes || (HslIndexes = {}));\r\nexport class HslColorManager {\r\n    constructor() {\r\n        this.key = \"hsl\";\r\n        this.stringPrefix = \"hsl\";\r\n    }\r\n    handleColor(color) {\r\n        const colorValue = color.value, hslColor = colorValue.hsl ?? color.value;\r\n        if (hslColor.h !== undefined && hslColor.s !== undefined && hslColor.l !== undefined) {\r\n            return hslToRgb(hslColor);\r\n        }\r\n    }\r\n    handleRangeColor(color) {\r\n        const colorValue = color.value, hslColor = colorValue.hsl ?? color.value;\r\n        if (hslColor.h !== undefined && hslColor.l !== undefined) {\r\n            return hslToRgb({\r\n                h: getRangeValue(hslColor.h),\r\n                l: getRangeValue(hslColor.l),\r\n                s: getRangeValue(hslColor.s),\r\n            });\r\n        }\r\n    }\r\n    parseString(input) {\r\n        if (!input.startsWith(\"hsl\")) {\r\n            return;\r\n        }\r\n        const regex = /hsla?\\(\\s*(\\d+)\\s*[\\s,]\\s*(\\d+)%\\s*[\\s,]\\s*(\\d+)%\\s*([\\s,]\\s*(0|1|0?\\.\\d+|(\\d{1,3})%)\\s*)?\\)/i, result = regex.exec(input), minLength = 4, defaultAlpha = 1, radix = 10;\r\n        return result\r\n            ? hslaToRgba({\r\n                a: result.length > minLength ? parseAlpha(result[HslIndexes.a]) : defaultAlpha,\r\n                h: parseInt(result[HslIndexes.h], radix),\r\n                l: parseInt(result[HslIndexes.l], radix),\r\n                s: parseInt(result[HslIndexes.s], radix),\r\n            })\r\n            : undefined;\r\n    }\r\n}\r\n", "import { HslColorManager } from \"./HslColorManager.js\";\r\nexport async function loadHslColorPlugin(engine, refresh = true) {\r\n    engine.checkVersion(\"3.8.1\");\r\n    await engine.addColorManager(new HslColorManager(), refresh);\r\n}\r\n", "import { getRandom, getRangeValue, initParticleNumericAnimationValue, percentDenominator, updateAnimation, } from \"@tsparticles/engine\";\r\nexport class OpacityUpdater {\r\n    constructor(container) {\r\n        this.container = container;\r\n    }\r\n    init(particle) {\r\n        const opacityOptions = particle.options.opacity, pxRatio = 1;\r\n        particle.opacity = initParticleNumericAnimationValue(opacityOptions, pxRatio);\r\n        const opacityAnimation = opacityOptions.animation;\r\n        if (opacityAnimation.enable) {\r\n            particle.opacity.velocity =\r\n                (getRangeValue(opacityAnimation.speed) / percentDenominator) * this.container.retina.reduceFactor;\r\n            if (!opacityAnimation.sync) {\r\n                particle.opacity.velocity *= getRandom();\r\n            }\r\n        }\r\n    }\r\n    isEnabled(particle) {\r\n        const none = 0;\r\n        return (!particle.destroyed &&\r\n            !particle.spawning &&\r\n            !!particle.opacity &&\r\n            particle.opacity.enable &&\r\n            ((particle.opacity.maxLoops ?? none) <= none ||\r\n                ((particle.opacity.maxLoops ?? none) > none &&\r\n                    (particle.opacity.loops ?? none) < (particle.opacity.maxLoops ?? none))));\r\n    }\r\n    reset(particle) {\r\n        if (particle.opacity) {\r\n            particle.opacity.time = 0;\r\n            particle.opacity.loops = 0;\r\n        }\r\n    }\r\n    update(particle, delta) {\r\n        if (!this.isEnabled(particle) || !particle.opacity) {\r\n            return;\r\n        }\r\n        updateAnimation(particle, particle.opacity, true, particle.options.opacity.animation.destroy, delta);\r\n    }\r\n}\r\n", "import { OpacityUpdater } from \"./OpacityUpdater.js\";\r\nexport async function loadOpacityUpdater(engine, refresh = true) {\r\n    engine.checkVersion(\"3.8.1\");\r\n    await engine.addParticleUpdater(\"opacity\", container => {\r\n        return Promise.resolve(new OpacityUpdater(container));\r\n    }, refresh);\r\n}\r\n", "import { OutMode, OutModeDirection, getRangeValue } from \"@tsparticles/engine\";\r\nconst minVelocity = 0, boundsMin = 0;\r\nexport function bounceHorizontal(data) {\r\n    if ((data.outMode !== OutMode.bounce && data.outMode !== OutMode.split) ||\r\n        (data.direction !== OutModeDirection.left && data.direction !== OutModeDirection.right)) {\r\n        return;\r\n    }\r\n    if (data.bounds.right < boundsMin && data.direction === OutModeDirection.left) {\r\n        data.particle.position.x = data.size + data.offset.x;\r\n    }\r\n    else if (data.bounds.left > data.canvasSize.width && data.direction === OutModeDirection.right) {\r\n        data.particle.position.x = data.canvasSize.width - data.size - data.offset.x;\r\n    }\r\n    const velocity = data.particle.velocity.x;\r\n    let bounced = false;\r\n    if ((data.direction === OutModeDirection.right &&\r\n        data.bounds.right >= data.canvasSize.width &&\r\n        velocity > minVelocity) ||\r\n        (data.direction === OutModeDirection.left && data.bounds.left <= boundsMin && velocity < minVelocity)) {\r\n        const newVelocity = getRangeValue(data.particle.options.bounce.horizontal.value);\r\n        data.particle.velocity.x *= -newVelocity;\r\n        bounced = true;\r\n    }\r\n    if (!bounced) {\r\n        return;\r\n    }\r\n    const minPos = data.offset.x + data.size;\r\n    if (data.bounds.right >= data.canvasSize.width && data.direction === OutModeDirection.right) {\r\n        data.particle.position.x = data.canvasSize.width - minPos;\r\n    }\r\n    else if (data.bounds.left <= boundsMin && data.direction === OutModeDirection.left) {\r\n        data.particle.position.x = minPos;\r\n    }\r\n    if (data.outMode === OutMode.split) {\r\n        data.particle.destroy();\r\n    }\r\n}\r\nexport function bounceVertical(data) {\r\n    if ((data.outMode !== OutMode.bounce && data.outMode !== OutMode.split) ||\r\n        (data.direction !== OutModeDirection.bottom && data.direction !== OutModeDirection.top)) {\r\n        return;\r\n    }\r\n    if (data.bounds.bottom < boundsMin && data.direction === OutModeDirection.top) {\r\n        data.particle.position.y = data.size + data.offset.y;\r\n    }\r\n    else if (data.bounds.top > data.canvasSize.height && data.direction === OutModeDirection.bottom) {\r\n        data.particle.position.y = data.canvasSize.height - data.size - data.offset.y;\r\n    }\r\n    const velocity = data.particle.velocity.y;\r\n    let bounced = false;\r\n    if ((data.direction === OutModeDirection.bottom &&\r\n        data.bounds.bottom >= data.canvasSize.height &&\r\n        velocity > minVelocity) ||\r\n        (data.direction === OutModeDirection.top && data.bounds.top <= boundsMin && velocity < minVelocity)) {\r\n        const newVelocity = getRangeValue(data.particle.options.bounce.vertical.value);\r\n        data.particle.velocity.y *= -newVelocity;\r\n        bounced = true;\r\n    }\r\n    if (!bounced) {\r\n        return;\r\n    }\r\n    const minPos = data.offset.y + data.size;\r\n    if (data.bounds.bottom >= data.canvasSize.height && data.direction === OutModeDirection.bottom) {\r\n        data.particle.position.y = data.canvasSize.height - minPos;\r\n    }\r\n    else if (data.bounds.top <= boundsMin && data.direction === OutModeDirection.top) {\r\n        data.particle.position.y = minPos;\r\n    }\r\n    if (data.outMode === OutMode.split) {\r\n        data.particle.destroy();\r\n    }\r\n}\r\n", "import { OutMode, calculateBounds, } from \"@tsparticles/engine\";\r\nimport { bounceHorizontal, bounceVertical } from \"./Utils.js\";\r\nexport class BounceOutMode {\r\n    constructor(container) {\r\n        this.container = container;\r\n        this.modes = [\r\n            OutMode.bounce,\r\n            OutMode.split,\r\n        ];\r\n    }\r\n    update(particle, direction, delta, outMode) {\r\n        if (!this.modes.includes(outMode)) {\r\n            return;\r\n        }\r\n        const container = this.container;\r\n        let handled = false;\r\n        for (const plugin of container.plugins.values()) {\r\n            if (plugin.particleBounce !== undefined) {\r\n                handled = plugin.particleBounce(particle, delta, direction);\r\n            }\r\n            if (handled) {\r\n                break;\r\n            }\r\n        }\r\n        if (handled) {\r\n            return;\r\n        }\r\n        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = calculateBounds(pos, size), canvasSize = container.canvas.size;\r\n        bounceHorizontal({ particle, outMode, direction, bounds, canvasSize, offset, size });\r\n        bounceVertical({ particle, outMode, direction, bounds, canvasSize, offset, size });\r\n    }\r\n}\r\n", "import { OutMode, ParticleOutType, Vector, getDistances, isPointInside, } from \"@tsparticles/engine\";\r\nconst minVelocity = 0;\r\nexport class DestroyOutMode {\r\n    constructor(container) {\r\n        this.container = container;\r\n        this.modes = [OutMode.destroy];\r\n    }\r\n    update(particle, direction, _delta, outMode) {\r\n        if (!this.modes.includes(outMode)) {\r\n            return;\r\n        }\r\n        const container = this.container;\r\n        switch (particle.outType) {\r\n            case ParticleOutType.normal:\r\n            case ParticleOutType.outside:\r\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\r\n                    return;\r\n                }\r\n                break;\r\n            case ParticleOutType.inside: {\r\n                const { dx, dy } = getDistances(particle.position, particle.moveCenter), { x: vx, y: vy } = particle.velocity;\r\n                if ((vx < minVelocity && dx > particle.moveCenter.radius) ||\r\n                    (vy < minVelocity && dy > particle.moveCenter.radius) ||\r\n                    (vx >= minVelocity && dx < -particle.moveCenter.radius) ||\r\n                    (vy >= minVelocity && dy < -particle.moveCenter.radius)) {\r\n                    return;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        container.particles.remove(particle, particle.group, true);\r\n    }\r\n}\r\n", "import { OutMode, OutModeDirection, Vector, isPointInside, } from \"@tsparticles/engine\";\r\nconst minVelocity = 0;\r\nexport class NoneOutMode {\r\n    constructor(container) {\r\n        this.container = container;\r\n        this.modes = [OutMode.none];\r\n    }\r\n    update(particle, direction, delta, outMode) {\r\n        if (!this.modes.includes(outMode)) {\r\n            return;\r\n        }\r\n        if ((particle.options.move.distance.horizontal &&\r\n            (direction === OutModeDirection.left || direction === OutModeDirection.right)) ??\r\n            (particle.options.move.distance.vertical &&\r\n                (direction === OutModeDirection.top || direction === OutModeDirection.bottom))) {\r\n            return;\r\n        }\r\n        const gravityOptions = particle.options.move.gravity, container = this.container, canvasSize = container.canvas.size, pRadius = particle.getRadius();\r\n        if (!gravityOptions.enable) {\r\n            if ((particle.velocity.y > minVelocity && particle.position.y <= canvasSize.height + pRadius) ||\r\n                (particle.velocity.y < minVelocity && particle.position.y >= -pRadius) ||\r\n                (particle.velocity.x > minVelocity && particle.position.x <= canvasSize.width + pRadius) ||\r\n                (particle.velocity.x < minVelocity && particle.position.x >= -pRadius)) {\r\n                return;\r\n            }\r\n            if (!isPointInside(particle.position, container.canvas.size, Vector.origin, pRadius, direction)) {\r\n                container.particles.remove(particle);\r\n            }\r\n        }\r\n        else {\r\n            const position = particle.position;\r\n            if ((!gravityOptions.inverse &&\r\n                position.y > canvasSize.height + pRadius &&\r\n                direction === OutModeDirection.bottom) ||\r\n                (gravityOptions.inverse && position.y < -pRadius && direction === OutModeDirection.top)) {\r\n                container.particles.remove(particle);\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { OutMode, OutModeDirection, ParticleOutType, Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange, } from \"@tsparticles/engine\";\r\nconst minVelocity = 0, minDistance = 0;\r\nexport class OutOutMode {\r\n    constructor(container) {\r\n        this.container = container;\r\n        this.modes = [OutMode.out];\r\n    }\r\n    update(particle, direction, delta, outMode) {\r\n        if (!this.modes.includes(outMode)) {\r\n            return;\r\n        }\r\n        const container = this.container;\r\n        switch (particle.outType) {\r\n            case ParticleOutType.inside: {\r\n                const { x: vx, y: vy } = particle.velocity;\r\n                const circVec = Vector.origin;\r\n                circVec.length = particle.moveCenter.radius;\r\n                circVec.angle = particle.velocity.angle + Math.PI;\r\n                circVec.addTo(Vector.create(particle.moveCenter));\r\n                const { dx, dy } = getDistances(particle.position, circVec);\r\n                if ((vx <= minVelocity && dx >= minDistance) ||\r\n                    (vy <= minVelocity && dy >= minDistance) ||\r\n                    (vx >= minVelocity && dx <= minDistance) ||\r\n                    (vy >= minVelocity && dy <= minDistance)) {\r\n                    return;\r\n                }\r\n                particle.position.x = Math.floor(randomInRange({\r\n                    min: 0,\r\n                    max: container.canvas.size.width,\r\n                }));\r\n                particle.position.y = Math.floor(randomInRange({\r\n                    min: 0,\r\n                    max: container.canvas.size.height,\r\n                }));\r\n                const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);\r\n                particle.direction = Math.atan2(-newDy, -newDx);\r\n                particle.velocity.angle = particle.direction;\r\n                break;\r\n            }\r\n            default: {\r\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\r\n                    return;\r\n                }\r\n                switch (particle.outType) {\r\n                    case ParticleOutType.outside: {\r\n                        particle.position.x =\r\n                            Math.floor(randomInRange({\r\n                                min: -particle.moveCenter.radius,\r\n                                max: particle.moveCenter.radius,\r\n                            })) + particle.moveCenter.x;\r\n                        particle.position.y =\r\n                            Math.floor(randomInRange({\r\n                                min: -particle.moveCenter.radius,\r\n                                max: particle.moveCenter.radius,\r\n                            })) + particle.moveCenter.y;\r\n                        const { dx, dy } = getDistances(particle.position, particle.moveCenter);\r\n                        if (particle.moveCenter.radius) {\r\n                            particle.direction = Math.atan2(dy, dx);\r\n                            particle.velocity.angle = particle.direction;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case ParticleOutType.normal: {\r\n                        const warp = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {\r\n                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\r\n                            left: -particle.getRadius() - particle.offset.x,\r\n                            right: canvasSize.width + particle.getRadius() + particle.offset.x,\r\n                            top: -particle.getRadius() - particle.offset.y,\r\n                        }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);\r\n                        if (direction === OutModeDirection.right &&\r\n                            nextBounds.left > canvasSize.width + particle.offset.x) {\r\n                            particle.position.x = newPos.left;\r\n                            particle.initialPosition.x = particle.position.x;\r\n                            if (!warp) {\r\n                                particle.position.y = getRandom() * canvasSize.height;\r\n                                particle.initialPosition.y = particle.position.y;\r\n                            }\r\n                        }\r\n                        else if (direction === OutModeDirection.left && nextBounds.right < -particle.offset.x) {\r\n                            particle.position.x = newPos.right;\r\n                            particle.initialPosition.x = particle.position.x;\r\n                            if (!warp) {\r\n                                particle.position.y = getRandom() * canvasSize.height;\r\n                                particle.initialPosition.y = particle.position.y;\r\n                            }\r\n                        }\r\n                        if (direction === OutModeDirection.bottom &&\r\n                            nextBounds.top > canvasSize.height + particle.offset.y) {\r\n                            if (!warp) {\r\n                                particle.position.x = getRandom() * canvasSize.width;\r\n                                particle.initialPosition.x = particle.position.x;\r\n                            }\r\n                            particle.position.y = newPos.top;\r\n                            particle.initialPosition.y = particle.position.y;\r\n                        }\r\n                        else if (direction === OutModeDirection.top && nextBounds.bottom < -particle.offset.y) {\r\n                            if (!warp) {\r\n                                particle.position.x = getRandom() * canvasSize.width;\r\n                                particle.initialPosition.x = particle.position.x;\r\n                            }\r\n                            particle.position.y = newPos.bottom;\r\n                            particle.initialPosition.y = particle.position.y;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { OutMode, OutModeDirection, } from \"@tsparticles/engine\";\r\nimport { BounceOutMode } from \"./BounceOutMode.js\";\r\nimport { DestroyOutMode } from \"./DestroyOutMode.js\";\r\nimport { NoneOutMode } from \"./NoneOutMode.js\";\r\nimport { OutOutMode } from \"./OutOutMode.js\";\r\nconst checkOutMode = (outModes, outMode) => {\r\n    return (outModes.default === outMode ||\r\n        outModes.bottom === outMode ||\r\n        outModes.left === outMode ||\r\n        outModes.right === outMode ||\r\n        outModes.top === outMode);\r\n};\r\nexport class OutOfCanvasUpdater {\r\n    constructor(container) {\r\n        this._addUpdaterIfMissing = (particle, outMode, getUpdater) => {\r\n            const outModes = particle.options.move.outModes;\r\n            if (!this.updaters.has(outMode) && checkOutMode(outModes, outMode)) {\r\n                this.updaters.set(outMode, getUpdater(this.container));\r\n            }\r\n        };\r\n        this._updateOutMode = (particle, delta, outMode, direction) => {\r\n            for (const updater of this.updaters.values()) {\r\n                updater.update(particle, direction, delta, outMode);\r\n            }\r\n        };\r\n        this.container = container;\r\n        this.updaters = new Map();\r\n    }\r\n    init(particle) {\r\n        this._addUpdaterIfMissing(particle, OutMode.bounce, container => new BounceOutMode(container));\r\n        this._addUpdaterIfMissing(particle, OutMode.out, container => new OutOutMode(container));\r\n        this._addUpdaterIfMissing(particle, OutMode.destroy, container => new DestroyOutMode(container));\r\n        this._addUpdaterIfMissing(particle, OutMode.none, container => new NoneOutMode(container));\r\n    }\r\n    isEnabled(particle) {\r\n        return !particle.destroyed && !particle.spawning;\r\n    }\r\n    update(particle, delta) {\r\n        const outModes = particle.options.move.outModes;\r\n        this._updateOutMode(particle, delta, outModes.bottom ?? outModes.default, OutModeDirection.bottom);\r\n        this._updateOutMode(particle, delta, outModes.left ?? outModes.default, OutModeDirection.left);\r\n        this._updateOutMode(particle, delta, outModes.right ?? outModes.default, OutModeDirection.right);\r\n        this._updateOutMode(particle, delta, outModes.top ?? outModes.default, OutModeDirection.top);\r\n    }\r\n}\r\n", "import { OutOfCanvasUpdater } from \"./OutOfCanvasUpdater.js\";\r\nexport async function loadOutModesUpdater(engine, refresh = true) {\r\n    engine.checkVersion(\"3.8.1\");\r\n    await engine.addParticleUpdater(\"outModes\", container => {\r\n        return Promise.resolve(new OutOfCanvasUpdater(container));\r\n    }, refresh);\r\n}\r\n", "import { getRangeValue, parseAlpha, } from \"@tsparticles/engine\";\r\nvar RgbIndexes;\r\n(function (RgbIndexes) {\r\n    RgbIndexes[RgbIndexes[\"r\"] = 1] = \"r\";\r\n    RgbIndexes[RgbIndexes[\"g\"] = 2] = \"g\";\r\n    RgbIndexes[RgbIndexes[\"b\"] = 3] = \"b\";\r\n    RgbIndexes[RgbIndexes[\"a\"] = 5] = \"a\";\r\n})(RgbIndexes || (RgbIndexes = {}));\r\nexport class RgbColorManager {\r\n    constructor() {\r\n        this.key = \"rgb\";\r\n        this.stringPrefix = \"rgb\";\r\n    }\r\n    handleColor(color) {\r\n        const colorValue = color.value, rgbColor = colorValue.rgb ?? color.value;\r\n        if (rgbColor.r !== undefined) {\r\n            return rgbColor;\r\n        }\r\n    }\r\n    handleRangeColor(color) {\r\n        const colorValue = color.value, rgbColor = colorValue.rgb ?? color.value;\r\n        if (rgbColor.r !== undefined) {\r\n            return {\r\n                r: getRangeValue(rgbColor.r),\r\n                g: getRangeValue(rgbColor.g),\r\n                b: getRangeValue(rgbColor.b),\r\n            };\r\n        }\r\n    }\r\n    parseString(input) {\r\n        if (!input.startsWith(this.stringPrefix)) {\r\n            return;\r\n        }\r\n        const regex = /rgba?\\(\\s*(\\d{1,3})\\s*[\\s,]\\s*(\\d{1,3})\\s*[\\s,]\\s*(\\d{1,3})\\s*([\\s,]\\s*(0|1|0?\\.\\d+|(\\d{1,3})%)\\s*)?\\)/i, result = regex.exec(input), radix = 10, minLength = 4, defaultAlpha = 1;\r\n        return result\r\n            ? {\r\n                a: result.length > minLength ? parseAlpha(result[RgbIndexes.a]) : defaultAlpha,\r\n                b: parseInt(result[RgbIndexes.b], radix),\r\n                g: parseInt(result[RgbIndexes.g], radix),\r\n                r: parseInt(result[RgbIndexes.r], radix),\r\n            }\r\n            : undefined;\r\n    }\r\n}\r\n", "import { RgbColorManager } from \"./RgbColorManager.js\";\r\nexport async function loadRgbColorPlugin(engine, refresh = true) {\r\n    engine.checkVersion(\"3.8.1\");\r\n    await engine.addColorManager(new RgbColorManager(), refresh);\r\n}\r\n", "import { getRandom, percentDenominator, updateAnimation, } from \"@tsparticles/engine\";\r\nconst minLoops = 0;\r\nexport class SizeUpdater {\r\n    init(particle) {\r\n        const container = particle.container, sizeOptions = particle.options.size, sizeAnimation = sizeOptions.animation;\r\n        if (sizeAnimation.enable) {\r\n            particle.size.velocity =\r\n                ((particle.retina.sizeAnimationSpeed ?? container.retina.sizeAnimationSpeed) / percentDenominator) *\r\n                    container.retina.reduceFactor;\r\n            if (!sizeAnimation.sync) {\r\n                particle.size.velocity *= getRandom();\r\n            }\r\n        }\r\n    }\r\n    isEnabled(particle) {\r\n        return (!particle.destroyed &&\r\n            !particle.spawning &&\r\n            particle.size.enable &&\r\n            ((particle.size.maxLoops ?? minLoops) <= minLoops ||\r\n                ((particle.size.maxLoops ?? minLoops) > minLoops &&\r\n                    (particle.size.loops ?? minLoops) < (particle.size.maxLoops ?? minLoops))));\r\n    }\r\n    reset(particle) {\r\n        particle.size.loops = minLoops;\r\n    }\r\n    update(particle, delta) {\r\n        if (!this.isEnabled(particle)) {\r\n            return;\r\n        }\r\n        updateAnimation(particle, particle.size, true, particle.options.size.animation.destroy, delta);\r\n    }\r\n}\r\n", "import { SizeUpdater } from \"./SizeUpdater.js\";\r\nexport async function loadSizeUpdater(engine, refresh = true) {\r\n    engine.checkVersion(\"3.8.1\");\r\n    await engine.addParticleUpdater(\"size\", () => {\r\n        return Promise.resolve(new SizeUpdater());\r\n    }, refresh);\r\n}\r\n", "import { loadBaseMover } from \"@tsparticles/move-base\";\r\nimport { loadCircleShape } from \"@tsparticles/shape-circle\";\r\nimport { loadColorUpdater } from \"@tsparticles/updater-color\";\r\nimport { loadHexColorPlugin } from \"@tsparticles/plugin-hex-color\";\r\nimport { loadHslColorPlugin } from \"@tsparticles/plugin-hsl-color\";\r\nimport { loadOpacityUpdater } from \"@tsparticles/updater-opacity\";\r\nimport { loadOutModesUpdater } from \"@tsparticles/updater-out-modes\";\r\nimport { loadRgbColorPlugin } from \"@tsparticles/plugin-rgb-color\";\r\nimport { loadSizeUpdater } from \"@tsparticles/updater-size\";\r\nexport async function loadBasic(engine, refresh = true) {\r\n    engine.checkVersion(\"3.8.1\");\r\n    await loadHexColorPlugin(engine, false);\r\n    await loadHslColorPlugin(engine, false);\r\n    await loadRgbColorPlugin(engine, false);\r\n    await loadBaseMover(engine, false);\r\n    await loadCircleShape(engine, false);\r\n    await loadColorUpdater(engine, false);\r\n    await loadOpacityUpdater(engine, false);\r\n    await loadOutModesUpdater(engine, false);\r\n    await loadSizeUpdater(engine, false);\r\n    await engine.refresh(refresh);\r\n}\r\n", "import { Circle, Rectangle } from \"@tsparticles/engine\";\r\nconst double = 2;\r\nexport class CircleWarp extends Circle {\r\n    constructor(x, y, radius, canvasSize) {\r\n        super(x, y, radius);\r\n        this.canvasSize = canvasSize;\r\n        this.canvasSize = { ...canvasSize };\r\n    }\r\n    contains(point) {\r\n        const { width, height } = this.canvasSize, { x, y } = point;\r\n        return (super.contains(point) ||\r\n            super.contains({ x: x - width, y }) ||\r\n            super.contains({ x: x - width, y: y - height }) ||\r\n            super.contains({ x, y: y - height }));\r\n    }\r\n    intersects(range) {\r\n        if (super.intersects(range)) {\r\n            return true;\r\n        }\r\n        const rect = range, circle = range, newPos = {\r\n            x: range.position.x - this.canvasSize.width,\r\n            y: range.position.y - this.canvasSize.height,\r\n        };\r\n        if (circle.radius !== undefined) {\r\n            const biggerCircle = new Circle(newPos.x, newPos.y, circle.radius * double);\r\n            return super.intersects(biggerCircle);\r\n        }\r\n        else if (rect.size !== undefined) {\r\n            const rectSW = new Rectangle(newPos.x, newPos.y, rect.size.width * double, rect.size.height * double);\r\n            return super.intersects(rectSW);\r\n        }\r\n        return false;\r\n    }\r\n}\r\n", "import { OptionsColor, isNull } from \"@tsparticles/engine\";\r\nexport class LinksShadow {\r\n    constructor() {\r\n        this.blur = 5;\r\n        this.color = new OptionsColor();\r\n        this.color.value = \"#000\";\r\n        this.enable = false;\r\n    }\r\n    load(data) {\r\n        if (isNull(data)) {\r\n            return;\r\n        }\r\n        if (data.blur !== undefined) {\r\n            this.blur = data.blur;\r\n        }\r\n        this.color = OptionsColor.create(this.color, data.color);\r\n        if (data.enable !== undefined) {\r\n            this.enable = data.enable;\r\n        }\r\n    }\r\n}\r\n", "import { OptionsColor, isNull } from \"@tsparticles/engine\";\r\nexport class LinksTriangle {\r\n    constructor() {\r\n        this.enable = false;\r\n        this.frequency = 1;\r\n    }\r\n    load(data) {\r\n        if (isNull(data)) {\r\n            return;\r\n        }\r\n        if (data.color !== undefined) {\r\n            this.color = OptionsColor.create(this.color, data.color);\r\n        }\r\n        if (data.enable !== undefined) {\r\n            this.enable = data.enable;\r\n        }\r\n        if (data.frequency !== undefined) {\r\n            this.frequency = data.frequency;\r\n        }\r\n        if (data.opacity !== undefined) {\r\n            this.opacity = data.opacity;\r\n        }\r\n    }\r\n}\r\n", "import { OptionsColor, isNull } from \"@tsparticles/engine\";\r\nimport { LinksShadow } from \"./LinksShadow.js\";\r\nimport { LinksTriangle } from \"./LinksTriangle.js\";\r\nexport class Links {\r\n    constructor() {\r\n        this.blink = false;\r\n        this.color = new OptionsColor();\r\n        this.color.value = \"#fff\";\r\n        this.consent = false;\r\n        this.distance = 100;\r\n        this.enable = false;\r\n        this.frequency = 1;\r\n        this.opacity = 1;\r\n        this.shadow = new LinksShadow();\r\n        this.triangles = new LinksTriangle();\r\n        this.width = 1;\r\n        this.warp = false;\r\n    }\r\n    load(data) {\r\n        if (isNull(data)) {\r\n            return;\r\n        }\r\n        if (data.id !== undefined) {\r\n            this.id = data.id;\r\n        }\r\n        if (data.blink !== undefined) {\r\n            this.blink = data.blink;\r\n        }\r\n        this.color = OptionsColor.create(this.color, data.color);\r\n        if (data.consent !== undefined) {\r\n            this.consent = data.consent;\r\n        }\r\n        if (data.distance !== undefined) {\r\n            this.distance = data.distance;\r\n        }\r\n        if (data.enable !== undefined) {\r\n            this.enable = data.enable;\r\n        }\r\n        if (data.frequency !== undefined) {\r\n            this.frequency = data.frequency;\r\n        }\r\n        if (data.opacity !== undefined) {\r\n            this.opacity = data.opacity;\r\n        }\r\n        this.shadow.load(data.shadow);\r\n        this.triangles.load(data.triangles);\r\n        if (data.width !== undefined) {\r\n            this.width = data.width;\r\n        }\r\n        if (data.warp !== undefined) {\r\n            this.warp = data.warp;\r\n        }\r\n    }\r\n}\r\n", "import { Circle, ParticlesInteractorBase, getDistances, getLinkRandomColor, } from \"@tsparticles/engine\";\r\nimport { CircleWarp } from \"./CircleWarp.js\";\r\nimport { Links } from \"./Options/Classes/Links.js\";\r\nconst squarePower = 2, opacityOffset = 1, origin = {\r\n    x: 0,\r\n    y: 0,\r\n}, minDistance = 0;\r\nfunction getLinkDistance(pos1, pos2, optDistance, canvasSize, warp) {\r\n    const { dx, dy, distance } = getDistances(pos1, pos2);\r\n    if (!warp || distance <= optDistance) {\r\n        return distance;\r\n    }\r\n    const absDiffs = {\r\n        x: Math.abs(dx),\r\n        y: Math.abs(dy),\r\n    }, warpDistances = {\r\n        x: Math.min(absDiffs.x, canvasSize.width - absDiffs.x),\r\n        y: Math.min(absDiffs.y, canvasSize.height - absDiffs.y),\r\n    };\r\n    return Math.sqrt(warpDistances.x ** squarePower + warpDistances.y ** squarePower);\r\n}\r\nexport class Linker extends ParticlesInteractorBase {\r\n    constructor(container, engine) {\r\n        super(container);\r\n        this._setColor = p1 => {\r\n            if (!p1.options.links) {\r\n                return;\r\n            }\r\n            const container = this._linkContainer, linksOptions = p1.options.links;\r\n            let linkColor = linksOptions.id === undefined\r\n                ? container.particles.linksColor\r\n                : container.particles.linksColors.get(linksOptions.id);\r\n            if (linkColor) {\r\n                return;\r\n            }\r\n            const optColor = linksOptions.color;\r\n            linkColor = getLinkRandomColor(this._engine, optColor, linksOptions.blink, linksOptions.consent);\r\n            if (linksOptions.id === undefined) {\r\n                container.particles.linksColor = linkColor;\r\n            }\r\n            else {\r\n                container.particles.linksColors.set(linksOptions.id, linkColor);\r\n            }\r\n        };\r\n        this._linkContainer = container;\r\n        this._engine = engine;\r\n    }\r\n    clear() {\r\n    }\r\n    init() {\r\n        this._linkContainer.particles.linksColor = undefined;\r\n        this._linkContainer.particles.linksColors = new Map();\r\n    }\r\n    interact(p1) {\r\n        if (!p1.options.links) {\r\n            return;\r\n        }\r\n        p1.links = [];\r\n        const pos1 = p1.getPosition(), container = this.container, canvasSize = container.canvas.size;\r\n        if (pos1.x < origin.x || pos1.y < origin.y || pos1.x > canvasSize.width || pos1.y > canvasSize.height) {\r\n            return;\r\n        }\r\n        const linkOpt1 = p1.options.links, optOpacity = linkOpt1.opacity, optDistance = p1.retina.linksDistance ?? minDistance, warp = linkOpt1.warp;\r\n        let range;\r\n        if (warp) {\r\n            range = new CircleWarp(pos1.x, pos1.y, optDistance, canvasSize);\r\n        }\r\n        else {\r\n            range = new Circle(pos1.x, pos1.y, optDistance);\r\n        }\r\n        const query = container.particles.quadTree.query(range);\r\n        for (const p2 of query) {\r\n            const linkOpt2 = p2.options.links;\r\n            if (p1 === p2 ||\r\n                !linkOpt2?.enable ||\r\n                linkOpt1.id !== linkOpt2.id ||\r\n                p2.spawning ||\r\n                p2.destroyed ||\r\n                !p2.links ||\r\n                p1.links.some(t => t.destination === p2) ||\r\n                p2.links.some(t => t.destination === p1)) {\r\n                continue;\r\n            }\r\n            const pos2 = p2.getPosition();\r\n            if (pos2.x < origin.x || pos2.y < origin.y || pos2.x > canvasSize.width || pos2.y > canvasSize.height) {\r\n                continue;\r\n            }\r\n            const distance = getLinkDistance(pos1, pos2, optDistance, canvasSize, warp && linkOpt2.warp);\r\n            if (distance > optDistance) {\r\n                continue;\r\n            }\r\n            const opacityLine = (opacityOffset - distance / optDistance) * optOpacity;\r\n            this._setColor(p1);\r\n            p1.links.push({\r\n                destination: p2,\r\n                opacity: opacityLine,\r\n            });\r\n        }\r\n    }\r\n    isEnabled(particle) {\r\n        return !!particle.options.links?.enable;\r\n    }\r\n    loadParticlesOptions(options, ...sources) {\r\n        if (!options.links) {\r\n            options.links = new Links();\r\n        }\r\n        for (const source of sources) {\r\n            options.links.load(source?.links);\r\n        }\r\n    }\r\n    reset() {\r\n    }\r\n}\r\n", "import { Linker } from \"./Linker.js\";\r\nexport async function loadLinksInteraction(engine, refresh = true) {\r\n    await engine.addInteractor(\"particlesLinks\", async (container) => {\r\n        return Promise.resolve(new Linker(container, engine));\r\n    }, refresh);\r\n}\r\n", "import { drawLine, getDistance, getDistances, getRandom, getStyleFromRgb, rangeColorToRgb, } from \"@tsparticles/engine\";\r\nexport function drawTriangle(context, p1, p2, p3) {\r\n    context.beginPath();\r\n    context.moveTo(p1.x, p1.y);\r\n    context.lineTo(p2.x, p2.y);\r\n    context.lineTo(p3.x, p3.y);\r\n    context.closePath();\r\n}\r\nexport function drawLinkLine(params) {\r\n    let drawn = false;\r\n    const { begin, end, engine, maxDistance, context, canvasSize, width, backgroundMask, colorLine, opacity, links } = params;\r\n    if (getDistance(begin, end) <= maxDistance) {\r\n        drawLine(context, begin, end);\r\n        drawn = true;\r\n    }\r\n    else if (links.warp) {\r\n        let pi1;\r\n        let pi2;\r\n        const endNE = {\r\n            x: end.x - canvasSize.width,\r\n            y: end.y,\r\n        };\r\n        const d1 = getDistances(begin, endNE);\r\n        if (d1.distance <= maxDistance) {\r\n            const yi = begin.y - (d1.dy / d1.dx) * begin.x;\r\n            pi1 = { x: 0, y: yi };\r\n            pi2 = { x: canvasSize.width, y: yi };\r\n        }\r\n        else {\r\n            const endSW = {\r\n                x: end.x,\r\n                y: end.y - canvasSize.height,\r\n            };\r\n            const d2 = getDistances(begin, endSW);\r\n            if (d2.distance <= maxDistance) {\r\n                const yi = begin.y - (d2.dy / d2.dx) * begin.x;\r\n                const xi = -yi / (d2.dy / d2.dx);\r\n                pi1 = { x: xi, y: 0 };\r\n                pi2 = { x: xi, y: canvasSize.height };\r\n            }\r\n            else {\r\n                const endSE = {\r\n                    x: end.x - canvasSize.width,\r\n                    y: end.y - canvasSize.height,\r\n                };\r\n                const d3 = getDistances(begin, endSE);\r\n                if (d3.distance <= maxDistance) {\r\n                    const yi = begin.y - (d3.dy / d3.dx) * begin.x;\r\n                    const xi = -yi / (d3.dy / d3.dx);\r\n                    pi1 = { x: xi, y: yi };\r\n                    pi2 = { x: pi1.x + canvasSize.width, y: pi1.y + canvasSize.height };\r\n                }\r\n            }\r\n        }\r\n        if (pi1 && pi2) {\r\n            drawLine(context, begin, pi1);\r\n            drawLine(context, end, pi2);\r\n            drawn = true;\r\n        }\r\n    }\r\n    if (!drawn) {\r\n        return;\r\n    }\r\n    context.lineWidth = width;\r\n    if (backgroundMask.enable) {\r\n        context.globalCompositeOperation = backgroundMask.composite;\r\n    }\r\n    context.strokeStyle = getStyleFromRgb(colorLine, opacity);\r\n    const { shadow } = links;\r\n    if (shadow.enable) {\r\n        const shadowColor = rangeColorToRgb(engine, shadow.color);\r\n        if (shadowColor) {\r\n            context.shadowBlur = shadow.blur;\r\n            context.shadowColor = getStyleFromRgb(shadowColor);\r\n        }\r\n    }\r\n    context.stroke();\r\n}\r\nexport function drawLinkTriangle(params) {\r\n    const { context, pos1, pos2, pos3, backgroundMask, colorTriangle, opacityTriangle } = params;\r\n    drawTriangle(context, pos1, pos2, pos3);\r\n    if (backgroundMask.enable) {\r\n        context.globalCompositeOperation = backgroundMask.composite;\r\n    }\r\n    context.fillStyle = getStyleFromRgb(colorTriangle, opacityTriangle);\r\n    context.fill();\r\n}\r\nexport function getLinkKey(ids) {\r\n    ids.sort((a, b) => a - b);\r\n    return ids.join(\"_\");\r\n}\r\nexport function setLinkFrequency(particles, dictionary) {\r\n    const key = getLinkKey(particles.map(t => t.id));\r\n    let res = dictionary.get(key);\r\n    if (res === undefined) {\r\n        res = getRandom();\r\n        dictionary.set(key, res);\r\n    }\r\n    return res;\r\n}\r\n", "import { getDistance, getLinkColor, getRandom, getRangeValue, rangeColorToRgb, } from \"@tsparticles/engine\";\r\nimport { drawLinkLine, drawLinkTriangle, setLinkFrequency } from \"./Utils.js\";\r\nconst minOpacity = 0, minWidth = 0, minDistance = 0, half = 0.5, maxFrequency = 1;\r\nexport class LinkInstance {\r\n    constructor(container, engine) {\r\n        this._drawLinkLine = (p1, link) => {\r\n            const p1LinksOptions = p1.options.links;\r\n            if (!p1LinksOptions?.enable) {\r\n                return;\r\n            }\r\n            const container = this._container, options = container.actualOptions, p2 = link.destination, pos1 = p1.getPosition(), pos2 = p2.getPosition();\r\n            let opacity = link.opacity;\r\n            container.canvas.draw(ctx => {\r\n                let colorLine;\r\n                const twinkle = p1.options.twinkle?.lines;\r\n                if (twinkle?.enable) {\r\n                    const twinkleFreq = twinkle.frequency, twinkleRgb = rangeColorToRgb(this._engine, twinkle.color), twinkling = getRandom() < twinkleFreq;\r\n                    if (twinkling && twinkleRgb) {\r\n                        colorLine = twinkleRgb;\r\n                        opacity = getRangeValue(twinkle.opacity);\r\n                    }\r\n                }\r\n                if (!colorLine) {\r\n                    const linkColor = p1LinksOptions.id !== undefined\r\n                        ? container.particles.linksColors.get(p1LinksOptions.id)\r\n                        : container.particles.linksColor;\r\n                    colorLine = getLinkColor(p1, p2, linkColor);\r\n                }\r\n                if (!colorLine) {\r\n                    return;\r\n                }\r\n                const width = p1.retina.linksWidth ?? minWidth, maxDistance = p1.retina.linksDistance ?? minDistance, { backgroundMask } = options;\r\n                drawLinkLine({\r\n                    context: ctx,\r\n                    width,\r\n                    begin: pos1,\r\n                    end: pos2,\r\n                    engine: this._engine,\r\n                    maxDistance,\r\n                    canvasSize: container.canvas.size,\r\n                    links: p1LinksOptions,\r\n                    backgroundMask: backgroundMask,\r\n                    colorLine,\r\n                    opacity,\r\n                });\r\n            });\r\n        };\r\n        this._drawLinkTriangle = (p1, link1, link2) => {\r\n            const linksOptions = p1.options.links;\r\n            if (!linksOptions?.enable) {\r\n                return;\r\n            }\r\n            const triangleOptions = linksOptions.triangles;\r\n            if (!triangleOptions.enable) {\r\n                return;\r\n            }\r\n            const container = this._container, options = container.actualOptions, p2 = link1.destination, p3 = link2.destination, opacityTriangle = triangleOptions.opacity ?? (link1.opacity + link2.opacity) * half;\r\n            if (opacityTriangle <= minOpacity) {\r\n                return;\r\n            }\r\n            container.canvas.draw(ctx => {\r\n                const pos1 = p1.getPosition(), pos2 = p2.getPosition(), pos3 = p3.getPosition(), linksDistance = p1.retina.linksDistance ?? minDistance;\r\n                if (getDistance(pos1, pos2) > linksDistance ||\r\n                    getDistance(pos3, pos2) > linksDistance ||\r\n                    getDistance(pos3, pos1) > linksDistance) {\r\n                    return;\r\n                }\r\n                let colorTriangle = rangeColorToRgb(this._engine, triangleOptions.color);\r\n                if (!colorTriangle) {\r\n                    const linkColor = linksOptions.id !== undefined\r\n                        ? container.particles.linksColors.get(linksOptions.id)\r\n                        : container.particles.linksColor;\r\n                    colorTriangle = getLinkColor(p1, p2, linkColor);\r\n                }\r\n                if (!colorTriangle) {\r\n                    return;\r\n                }\r\n                drawLinkTriangle({\r\n                    context: ctx,\r\n                    pos1,\r\n                    pos2,\r\n                    pos3,\r\n                    backgroundMask: options.backgroundMask,\r\n                    colorTriangle,\r\n                    opacityTriangle,\r\n                });\r\n            });\r\n        };\r\n        this._drawTriangles = (options, p1, link, p1Links) => {\r\n            const p2 = link.destination;\r\n            if (!(options.links?.triangles.enable && p2.options.links?.triangles.enable)) {\r\n                return;\r\n            }\r\n            const vertices = p2.links?.filter(t => {\r\n                const linkFreq = this._getLinkFrequency(p2, t.destination), minCount = 0;\r\n                return (p2.options.links &&\r\n                    linkFreq <= p2.options.links.frequency &&\r\n                    p1Links.findIndex(l => l.destination === t.destination) >= minCount);\r\n            });\r\n            if (!vertices?.length) {\r\n                return;\r\n            }\r\n            for (const vertex of vertices) {\r\n                const p3 = vertex.destination, triangleFreq = this._getTriangleFrequency(p1, p2, p3);\r\n                if (triangleFreq > options.links.triangles.frequency) {\r\n                    continue;\r\n                }\r\n                this._drawLinkTriangle(p1, link, vertex);\r\n            }\r\n        };\r\n        this._getLinkFrequency = (p1, p2) => {\r\n            return setLinkFrequency([p1, p2], this._freqs.links);\r\n        };\r\n        this._getTriangleFrequency = (p1, p2, p3) => {\r\n            return setLinkFrequency([p1, p2, p3], this._freqs.triangles);\r\n        };\r\n        this._container = container;\r\n        this._engine = engine;\r\n        this._freqs = {\r\n            links: new Map(),\r\n            triangles: new Map(),\r\n        };\r\n    }\r\n    drawParticle(context, particle) {\r\n        const { links, options } = particle;\r\n        if (!links?.length) {\r\n            return;\r\n        }\r\n        const p1Links = links.filter(l => options.links &&\r\n            (options.links.frequency >= maxFrequency ||\r\n                this._getLinkFrequency(particle, l.destination) <= options.links.frequency));\r\n        for (const link of p1Links) {\r\n            this._drawTriangles(options, particle, link, p1Links);\r\n            if (link.opacity > minOpacity && (particle.retina.linksWidth ?? minWidth) > minWidth) {\r\n                this._drawLinkLine(particle, link);\r\n            }\r\n        }\r\n    }\r\n    async init() {\r\n        this._freqs.links = new Map();\r\n        this._freqs.triangles = new Map();\r\n        await Promise.resolve();\r\n    }\r\n    particleCreated(particle) {\r\n        particle.links = [];\r\n        if (!particle.options.links) {\r\n            return;\r\n        }\r\n        const ratio = this._container.retina.pixelRatio, { retina } = particle, { distance, width } = particle.options.links;\r\n        retina.linksDistance = distance * ratio;\r\n        retina.linksWidth = width * ratio;\r\n    }\r\n    particleDestroyed(particle) {\r\n        particle.links = [];\r\n    }\r\n}\r\n", "import { LinkInstance } from \"./LinkInstance.js\";\r\nexport class LinksPlugin {\r\n    constructor(engine) {\r\n        this.id = \"links\";\r\n        this._engine = engine;\r\n    }\r\n    getPlugin(container) {\r\n        return Promise.resolve(new LinkInstance(container, this._engine));\r\n    }\r\n    loadOptions() {\r\n    }\r\n    needsPlugin() {\r\n        return true;\r\n    }\r\n}\r\n", "import { LinksPlugin } from \"./LinksPlugin.js\";\r\nexport async function loadLinksPlugin(engine, refresh = true) {\r\n    const plugin = new LinksPlugin(engine);\r\n    await engine.addPlugin(plugin, refresh);\r\n}\r\n", "import { loadLinksInteraction } from \"./interaction.js\";\r\nimport { loadLinksPlugin } from \"./plugin.js\";\r\nexport async function loadParticlesLinksInteraction(engine, refresh = true) {\r\n    engine.checkVersion(\"3.8.1\");\r\n    await loadLinksInteraction(engine, refresh);\r\n    await loadLinksPlugin(engine, refresh);\r\n}\r\nexport * from \"./Options/Classes/Links.js\";\r\nexport * from \"./Options/Classes/LinksShadow.js\";\r\nexport * from \"./Options/Classes/LinksTriangle.js\";\r\nexport * from \"./Options/Interfaces/ILinks.js\";\r\nexport * from \"./Options/Interfaces/ILinksShadow.js\";\r\nexport * from \"./Options/Interfaces/ILinksTriangle.js\";\r\n"],
  "mappings": "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",
  "names": ["spinFactor", "double", "doublePI", "minAngle", "RgbIndexes", "HslIndexes", "defaultAlpha", "minVelocity", "minVelocity", "minVelocity", "minVelocity", "RgbIndexes", "defaultAlpha", "double", "origin", "minDistance", "container", "minDistance", "half", "container"]
}
